// server.js
const express = require('express');
const bodyParser = require('body-parser');
const Minio = require('minio');
const cors = require('cors'); 

const app = express();
app.use(cors());   
app.use(bodyParser.json());


// K·∫øt n·ªëi t·ªõi MinIO (container ƒëang ch·∫°y ·ªü localhost:9000)
const minioClient = new Minio.Client({
  endPoint: 'localhost',
  port: 9000,
  useSSL: false,
  accessKey: 'admin',
  secretKey: '24082002'
});

const bucketName = 'thingsboard-data';

// ƒê·∫£m b·∫£o bucket t·ªìn t·∫°i
minioClient.bucketExists(bucketName, (err, exists) => {
  if (err) return console.error('‚ùå L·ªói ki·ªÉm tra bucket:', err);
  if (!exists) {
    minioClient.makeBucket(bucketName, 'us-east-1', (err) => {
      if (err) return console.error('‚ùå Kh√¥ng t·∫°o ƒë∆∞·ª£c bucket:', err);
      console.log('‚úÖ ƒê√£ t·∫°o bucket:', bucketName);
    });
  } else {
    console.log('‚úÖ Bucket ƒë√£ t·ªìn t·∫°i:', bucketName);
  }
});

// API nh·∫≠n d·ªØ li·ªáu t·ª´ ThingsBoard
app.post('/upload', async (req, res) => {
  try {
    const data = req.body;
    const filename = `tb_${Date.now()}.json`;
    const buffer = Buffer.from(JSON.stringify(data, null, 2), 'utf8');

    await minioClient.putObject(bucketName, filename, buffer);
    console.log('üì¶ ƒê√£ l∆∞u:', filename);

    res.json({ status: 'success', file: filename });
  } catch (err) {
    console.error('‚ùå L·ªói upload:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});


// üì§ API: Xu·∫•t danh s√°ch file trong bucket
app.get('/list', async (req, res) => {
  const files = [];
  const stream = minioClient.listObjectsV2(bucketName, '', true);
  stream.on('data', obj => files.push(obj.name));
  stream.on('end', () => res.json({ status: 'success', files }));
  stream.on('error', err => res.status(500).json({ error: err.message }));
});

// üì• API: T·∫£i v·ªÅ 1 file c·ª• th·ªÉ
app.get('/download/:filename', async (req, res) => {
  const filename = req.params.filename;
  try {
    const fileStream = await minioClient.getObject(bucketName, filename);
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    fileStream.pipe(res);
  } catch (err) {
    res.status(404).json({ error: 'File not found' });
  }
});


/// üìö API: Merge to√†n b·ªô file JSON trong h·ªì th√†nh 1 dataset (fix async)
app.get('/merged', async (req, res) => {
  const { device, from, to } = req.query;
  const dataset = [];

  try {
    // L·∫•y danh s√°ch file trong bucket
    const files = [];
    const stream = minioClient.listObjectsV2(bucketName, '', true);
    for await (const obj of stream) {
      if (obj.name.endsWith('.json')) files.push(obj.name);
    }

    // ƒê·ªçc t·ª´ng file tu·∫ßn t·ª±
    for (const fileName of files) {
      try {
        const fileStream = await minioClient.getObject(bucketName, fileName);
        const chunks = [];
        for await (const chunk of fileStream) chunks.push(chunk);
        const raw = Buffer.concat(chunks).toString();

        try {
          const json = JSON.parse(raw);

          if (json.device && json.timestamp) {
            if ((!device || json.device === device) &&
                (!from || json.timestamp >= from) &&
                (!to || json.timestamp <= to)) {
              dataset.push(json);
            }
          }
        } catch (err) {
          console.error(`‚ùå L·ªói parse JSON ·ªü file ${fileName}:`, err.message);
        }
      } catch (err) {
        console.error(`‚ùå L·ªói ƒë·ªçc file ${fileName}:`, err.message);
      }
    }

    // S·∫Øp x·∫øp k·∫øt qu·∫£ theo timestamp
    dataset.sort((a, b) => (a.timestamp || '').localeCompare(b.timestamp || ''));
    res.json({ status: 'success', total: dataset.length, dataset });

  } catch (err) {
    console.error('‚ùå L·ªói khi merge d·ªØ li·ªáu:', err.message);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

// ===================== üì¶ L·∫§Y DANH S√ÅCH THI·∫æT B·ªä T·ª™ D·ªÆ LI·ªÜU =====================
app.get('/devices', async (req, res) => {
  try {
    console.log('üì° ƒêang t·ªïng h·ª£p danh s√°ch thi·∫øt b·ªã...');
    const allData = [];

    // ‚úÖ 1. Li·ªát k√™ t·∫•t c·∫£ file trong bucket MinIO
    const stream = minioClient.listObjectsV2(bucketName, '', true);
    for await (const obj of stream) {
      if (obj.name.endsWith('.json')) {
        const chunks = [];
        const fileStream = await minioClient.getObject(bucketName, obj.name);
        for await (const chunk of fileStream) chunks.push(chunk);
        const content = Buffer.concat(chunks).toString('utf-8');

        try {
          const json = JSON.parse(content);
          // M·ªôt file c√≥ th·ªÉ l√† { device, temperature, humidity, timestamp }
          if (Array.isArray(json)) allData.push(...json);
          else allData.push(json);
        } catch (e) {
          console.error('‚ùå L·ªói ƒë·ªçc JSON t·ª´', obj.name);
        }
      }
    }

    // ‚úÖ 2. Gom nh√≥m d·ªØ li·ªáu theo thi·∫øt b·ªã
    const grouped = {};
    for (const rec of allData) {
      if (!rec.device) continue;
      if (!grouped[rec.device]) grouped[rec.device] = [];
      grouped[rec.device].push(rec);
    }

    // ‚úÖ 3. Chuy·ªÉn th√†nh danh s√°ch thi·∫øt b·ªã
    const devices = Object.keys(grouped).map((dev) => {
      const records = grouped[dev];
      const lastRecord = records[records.length - 1];
      const lastTime = lastRecord?.timestamp || null;

      // X√°c ƒë·ªãnh lo·∫°i thi·∫øt b·ªã d·ª±a theo t√™n
      let type = "Sensor";
      if (/temp/i.test(dev)) type = "Temperature";
      else if (/humi/i.test(dev)) type = "Humidity";
      else if (/gas/i.test(dev)) type = "Gas";
      else if (/motion/i.test(dev)) type = "Motion";
      else if (/pressure/i.test(dev)) type = "Pressure";
      else if (/water/i.test(dev)) type = "Water Level";
      else if (/light/i.test(dev)) type = "Light";
      else if (/power/i.test(dev)) type = "Power";

      // Ki·ªÉm tra th·ªùi gian ho·∫°t ƒë·ªông
      const now = new Date();
      const last = lastTime ? new Date(lastTime) : null;
      const diffMinutes = last ? (now - last) / (1000 * 60) : Infinity;
      let status = "offline";
      if (diffMinutes <= 2) status = "online";
      else if (diffMinutes <= 10) status = "warning";

      return {
        id: dev,
        name: dev,
        type,
        location: "Unknown", // sau n√†y b·∫°n c√≥ th·ªÉ b·ªï sung
        status,
        lastSeen: lastTime,
        dataPoints: records.length,
      };
    });

    // ‚úÖ 4. G·ª≠i k·∫øt qu·∫£ v·ªÅ frontend
    res.json({ devices });
  } catch (err) {
    console.error('‚ùå L·ªói l·∫•y danh s√°ch thi·∫øt b·ªã:', err);
    res.status(500).json({ error: 'Kh√¥ng th·ªÉ ƒë·ªçc danh s√°ch thi·∫øt b·ªã' });
  }
});

// g·ªôp chung react chung port
// ... c√°c route API: /upload, /list, /merged ·ªü ph√≠a tr√™n

const path = require('path');
app.use(express.static(path.join(__dirname, 'client', 'build')));

// B·∫Øt m·ªçi route kh√°c tr·∫£ v·ªÅ React
app.get(/.*/, (req, res) => {
  res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));
});
app.listen(5001, () => console.log('‚úÖ Server running on port 5001'));


const PORT = 5001;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ Node API ch·∫°y ·ªü http://0.0.0.0:${PORT}`);
});



